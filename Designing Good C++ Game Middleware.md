# Designing Good C++ Game Middleware

---

文章为[Designing Good C++ Game Middleware](<https://www.gamedev.net/articles/programming/general-and-gameplay-programming/designing-good-c-game-middleware-r5090/>)的阅读笔记(翻译)

纵观各种库，一个高性能的库应该：

* “不惜一切”提高性能
* 专注于特定集合的功能，而不是追求大而全(清晰的需求)
* 与引擎紧密联系？

下文将以伪代码的形式呈现一个刚体物理库(pseudo (rigid body) physics library)，以其作为例子，展示如何设计该库从而满足以上3个条件。

该库拥有一个"update"函数(stepSimulation)，该函数：

* 遍历所有的刚体
* 对这些刚体进行一个大致的碰撞检测，筛选出大概率会发生碰撞的刚体对
* 对筛选出来的刚体对进行更为细致的碰撞检测
* 将最后筛选出来确认发生碰撞的刚体对进行碰撞求解。

## 库的public接口

毋庸置疑，public接口是用户与库交互的重要途经。如何设计一个清晰明了，准确地表达出其功能的接口十分困难。一个好的public接口应该有以下几个特点: **minimal**,**documented**,**self documented**,**stable**,**flexible**,**extendable**

### minimal:

表示这个接口的功能尽量单一，不要再在内部牵扯其它的功能扰乱用户的直观感觉。(同时，作者也不推荐使用PIMPL以及一切会破坏内联的设计方式)(所以这里的小，也应该暗指函数体积(汇编层面上)小)

> PIMPL: 可能称为pointer-implementation的方法，即在pimpl函数内部包含了一个指针，该指针指向一个函数实现/包含该函数实现的类对象，而这个函数实现的功能正是pimpl函数期望实现的功能，通过调用指针指向的函数实现，pimpl可以在编译期(一般是)多态选择哪个函数实现才是最终需要的。详见[Pimpl](<https://zh.cppreference.com/w/cpp/language/pimpl>)

### Documentation

我理解为是有良好的注释说明，参数命名等，进而提高可读性。

### self-documented:

同样是提高代码的可读性，相比上一条，该特性强调编写的代码要清晰地表达作者的意图(逻辑)。比如对不需要修改的变量明确添加const修饰。一方面告诉用户变量的特点，另一方面有效阻止错误的发生。

## Data oriented design

作者在这里列举的例子是**指针数组**和**对象数组**的对比。同时有一个较为复杂的函数需要顺序遍历所有的对象。指针数组由于多了一层间接，很可能会破坏cache line。而对象数组则同时将附近的数据同时加载，从而通过减少cache miss提高性能。

> 作者的核心思想还是尽可能让对象组合在一起，减少cache miss.

## Thread Awareness

1. 随时注意哪些函数(对用户而言就是接口)是**线程安全**的，让用户知道多个线程同时使用该函数不会造成错误。对那些威胁到线程安全(引入读写冲突)的，需要给出提示。
2. 不要在库中引入多线程处理，而是将并行执行的*可能*留给用户，让用户提供“线程”，进而并行执行。
3. 关于锁，向用户提供并行代码可能需要锁。假如让用户加锁，则锁影响到的范围会比在函数内需要的地方加锁带来更多性能损耗。(这个应该值得商榷)

## Memory Management

让用户提供内存管理器。即接受一个内存分配对象/方法，这些对象/方法是用户自定义的内存分配策略。库需要做的就是提供必要的接口，让用户实现这些接口就完了。

同时，一个库可能需要多种内存分配策略，向用户请求所需要的各种分配策略的实现，将选择权交给用户。



> 永远把用户想像得比你更聪明——因为用户的使用场景你不一定能涵盖到。