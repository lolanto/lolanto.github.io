# 程序员的自我修养_笔记(三)

## 内存

这里所指的内存不加特殊说明，均是指*虚拟内存*

进程的内存主要分为四个部分：栈，堆，可执行文件映射以及保留区

### 栈——函数

栈是数据的容器，数据的插入与删除必须按照FIFO进行。**栈是函数执行的基础**，保存了寄存器状态，局部变量等信息。

当调用一个函数时，函数的参数会被首先压入栈中，紧接着是返回地址(函数返回后的下一条机器命令的地址)，再然后是函数运行时可能要修改的寄存器的当前值(保护现场)。以上的信息也被称为**栈帧(Stack Frame)**。

一般而言会使用esp和ebp两个寄存器记录当前函数调用栈的范围。ebp记录栈底，esp记录栈顶。由于栈是从高地址开始往下生长的，所以一般esp要小于ebp。

当函数需要申请局部变量时，通过减少esp的大小，即可扩大栈的大小，并利用新增加的空间初始化变量完成变量的申请。一般而言，操作系统会将新增加的栈空间初始化为0xCC(与操作系统有关)，以此表明该段栈空间没有被初始化。(*变量的申请必须保证手动初始化，切勿依赖自动初始化*)。

当函数退出时，通过移动esp的位置(将esp设置为ebp)来清理栈空间，ebp也通过之前压入栈的记录(old_ebp)恢复到调用者的栈底位置。

由于函数的调用涉及参数传递以及栈清理，需要调用者与被调用者之间有协议——压栈内容是什么，参数以何种顺序压栈，出栈过程由谁完成等。另外，协议中还会包括函数名称的修饰方式，这种协议称为**调用惯例**

一般c/c++的默认调用惯例是**cdecl**，如下：

```c++
int _cdecl func()
```

不同编译器的cdecl关键字不同，如声明中省略调用惯例，默认的就是cdecl。

还有其它调用惯例包括**stdcall**，**fastcall**以及**pascal**等，关键区别就是其协议内容的差别。不同的栈处理方式可以方便让调用者/被调用者完成一些特殊操作。

函数返回时除了需要清理栈空间，还需要存储返回值，一般而言是将返回值存储于eax寄存器中。但由于寄存器大小限制，不能返回大对象。当需要返回内容较大时，调用者的栈上会开辟一个临时空间(大小不一定等于返回对象的大小)，而eax记录该临时空间的地址，被调用者返回时，会将返回值写入到该临时空间中，调用者需要该返回值时，从eax读取临时空间的地址，并从临时空间中拷贝返回对象。这也解释了(未优化)c++返回对象时调用了两次拷贝构造函数的原因。

大对象返回方式的实现会受到编译器设置，平台类型的影响，二进制层面的移植可能会引发错误。

每个线程都拥有自己的栈，一般而言，栈是线程的私有空间，但不排除获得其它线程的栈地址后依然能够访问其它线程的栈空间。

### 堆——自由的内存空间

堆是程序运行时可动态管理的内存空间，堆内存的分配受操作系统的限制。

一般而言我们使用c运行库的malloc/free完成堆内存的申请与释放，然而这些函数都需要依赖操作系统的系统调用完成堆内存的申请。系统调用申请的堆大小必须是4K的整数倍(受平台限制，各部相同)，防止碎片申请降低性能；而malloc管理系统调用申请而来的堆，从已申请的堆中分配任意大小的堆空间给用户。

系统调用申请的堆空间是连续的(虚拟)内存空间，故一次申请所能获得的最大内存空间受限于当前进程内存空间中最大的空闲内存块。每次申请的堆空间不一定是连续的，可能在进程内存空间的不同位置。一个连续的(虚拟)堆空间映射到物理内存中也可能是不连续的。

一般而言堆是从低地址往上增长的，但受系统调用的限制，有时候这一规律不一定使用(windows)。进程结束后，虚拟内存空间被收回，申请的堆也会被收回。

堆的管理分配算法有很多，包括空闲链表，位图以及对象池等。

### 可执行文件映射

实际上是可执行文件中的某些段内容，比如指令段以及数据段；另外是动态链接对象的内容(同样的会有指令段和数据段)。

### 保留区

最典型的保留区即内核区域，用户程序无法访问该区域任何内容。

## 运行库

程序在执行main函数之前，还有很多事情需要完成，比如之前提及的动态链接的完成。在程序链接完后，还需要完成程序的初始化工作，包括栈生成(比如压入main的参数，运行环境参数)，堆申请，IO初始化，全局变量的初始化等工作。在这之后才会调用main开始执行我们编写的代码。

在执行完之后，程序还需要释放之前申请的全局变量，释放IO等工作并向操作系统返回运行结果(错误码)，这些代码都由运行库提供并在链接时插入到程序中。

> 目标文件中有.init以及.fini两个段，段内保存了目标文件中需要初始化，析构以及其它需要在程序运行以及结束时执行的机器指令。在最终链接时，链接器会将这些段合并起来，成为init以及fini函数，运行库在入口函数(非main)中对初始化函数进行调用，而在程序退出时清场。

另外，程序的运行没有操作系统的支持几乎不能正常执行，运行库作为应用程序与操作系统的中间层，协助程序完成操作系统相关的工作。在执行诸如读取文件，输出文本至控制台等操作都可以利用运行库完成。运行库在这些过程中充当**系统调用的抽象接口**。运行库通过提供保证完成上述操作的稳定接口，使得源代码能够在不同平台上进行编译运行。

不同平台上的运行库对相同功能的实现均不一样，因为不同平台的系统调用函数都不相同，故不同平台会提供自己的实现版本的库(与c++的stl类似)。

由于运行库所提供的功能在所有的平台上都应该被实现，所以一些特定平台能够提供的功能运行库是没有的。

## 系统调用

上述的运行库提供系统调用的抽象接口，事实上程序也可以直接进行系统调用。然而绕过运行库有可能降低代码的可移植性，但另一方面却能够使用平台特定的功能。

系统调用即请求系统完成某项内容，这使得进程会从**用户态**陷入到**内核态**。所谓的用户态和内核态，其区别在于指令的特权级别不同；特权级别不同导致指令能够进行的操作也不同；这是在操作系统层面上对指令进行的区分。实际上CPU本身也提供了不同的特权级别，保障不同级别的指令能够平稳工作。

内核态的指令特权级别更高，而用户态指令的特权级别低，无法对外部硬件进行直接的操作。

特权级别高的指令能够切换到特权级别低的指令，但特权级别低的指令不能直接切换到特权级别高的指令上。所以需要利用**中断**完成低特权到高特权指令的切换。

当进行系统调用时，系统调用的函数会向CPU发送**程序中断**命令，并将内核操作的代码以及其参数存到寄存器中；CPU获得中断命令后，执行操作系统内核的代码，内核代码读取寄存器中相关参数，执行指定的内核函数，完成后将控制权返回到用户代码(用户态)。

在切换状态的过程中，势必要切换**程序执行的上下文**，其中包括了用户代码当前正在使用的寄存器状态(包括esp,ebp)，这些内容会通通保存在内核态的栈和堆上，内核函数利用内核态的栈和堆执行函数，在执行完内核函数后，再从内核栈和堆中恢复寄存器状态。

> esp，ebp寄存的值标志着当前指令执行的栈的范围。当esp，ebp指向的是内核区域的内存时，当前指令使用的栈为内核栈；当esp和ebp指向的是用户进程区域时，则当前指令使用的是用户态的栈。

所以，系统调用的花销要比一般函数调用的花销更大。运行库对系统调用进行封装的目的还包括了提高需要系统调用的命令的效率。比如malloc，其实际运行中会通过系统调用申请足够大的堆并进行管理，使得用户频繁申请较小堆时不至于因为多次进行系统调用而拖垮性能。

### windows的API

windows的系统调用并未向用户公开，我们能够接触的windows最底层的接口即为windows API。与运行库类似，都是对系统调用的封装，然而windows上的运行库封装的却是windows api。

微软通过windows api的方式将底层的系统调用进行封装，使得系统升级时可以更改底层的系统调用实现，甚至接口，只用保证windows api接口一致即可。