# 内存对齐

内存对齐包括三个方面：数据对齐，数据结构扩展(对齐)以及分块策略(packing/打包)。暂时只清楚对齐的规则，至于为何需要对齐，尚未明白。

## 对齐的计算

### 地址对齐

当内存地址X能够被n整除，同时n是2的幂时，我们称X为n字节对齐的内存地址

### 数据对齐(自然对齐--naturally aligned)

假设数据在内存中的大小为M字节，数据地址为N，若N为M的倍数，即`N % M = 0`时，我们称该数据时对齐(自然对齐)的。否则该数据不对齐。

### 分块packing

编译器可以控制内存的packing方式，通过命令`#pragma pack(n)`完成，其中n必须是2的幂。可以使用`#pragma pack(push)`以及`#pragma pack(pop)`暂时更改某一段位置的代码的packing方式。packing可以用在数据传输上，适应不同平台的内存分配策略，n值的大小作用下面提及。

### 数据对齐(data alignment)

对结构体或者类而言都一样，每个结构体都分配首地址，第一个数据成员的地址与首地址的offset为0。其后的数据offset由如下规则决定：取`#pragma pack(n)`的n值与当前数据成员的大小的最小值N，offset必须为N的倍数。

这里讨论的结构体仅包含基本数据结构。

```c++
#pragma pack(4)
struct s {
  char c; // 1 byte
  double d; // 8 byte
};
```

c的offset为0，可以直接安排；由于d的大小大于pack值，所以d的offset必须是4的倍数，即offset为4。意味着在c和d之间有3字节的匿名空间用于对齐，整个数据结构的大小为12字节。

### 结构体对齐(struct padding)

当结构体中的所有数据成员已经对齐后，还需要对结构体整体进行对齐。结构体后需要添加如下字节：取`#pragma pack(n)`的n值与结构体中最大数据成员m的最小值N，结构体的大小必须是N的倍数。

这里讨论的结构体仅包含基本数据结构

```c++
#pragma pack(8)
struct s {
  char c; // 1 byte
  double d; // 8 byte
  int i; // 4 byte
};
```

上述结构数据成员对齐完成后，大小应为20字节，但由于结构本身需要对齐，且对齐的值为8(pack与double大小一样)，所以上述结构大小为24字节，有4字节的匿名空间用于对齐。

---

## 从CPU的角度看为什么需要内存对齐

首先声明的是32位cpu，64位cpu意味着cpu一次能够处理的数据量，其中就包括cpu寻址，故32位cpu能够寻址的地址由32位数据构成，整个地址空间中有2^32条地址，每条地址中存储1字节数据，故32位cpu能够寻址的内存空间为4GB。64位同理。

### 一种说法：高效利用L1缓存(cache line)

cpu发出的确实是某一个字节的地址，但由于cpu采用了缓存技术，故每次读取内存时都会从内存中读取缓存块(cache line/ cache block)大小的内存区域到缓存中。比如当前缓存块大小一般为64B，故地址空间每64个地址划分为1个缓存块。同一个缓存块中的所有地址有任意一个地址被cpu索引到，整个缓存块将被传到缓存中，所以可以理解为cpu是按块读取内存的，而且地址还是64字节对齐的(当且仅当内存地址是n的倍数时，称地址n字节对齐)。

为了提高缓存的命中率，我们希望**数据都尽量能够存储在一个缓存块中**；假如某个数据，比如double，高地址数据与低地址数据存在了两个块中，那么将需要刷新两个缓存块的数据才能完成数据的操作。

### 另一种说法：兼容处理器

不是所有的处理器都能够访问任意的内存地址，若cpu访问的地址不是对齐的，有些cpu会直接报错，而另外一些通过多个时钟周期完成访问，所以为了能够有效访问内存，内存还是需要对齐。

## 从程序的角度看为什么需要内存对齐

一般而言我们是不需要考虑内存对齐问题的，编译器会自动帮我们完成对齐任务。但当我们需要完成诸如内存空间优化(减少占用空间，如pack)，内存访问优化(对齐问题)或者进行reinterpret_cast类似的直接内存操作时，就需要考虑内存对齐的存在。

## Bonus

内存存储方式分大小端：高地址低字节为大端；低地址低字节为小端。

编译器一般不会修改结构体中声明的数据成员在内存中的排列位置；

在intel i3-4150，win10-64平台上，栈是从高地址往低地址生长；堆从低地址往高地址生长。结构体的第一个数据成员或者数组的0下标成员均在自己所属的内存区域的低字节位置，并往高字节方向填充数据成员；