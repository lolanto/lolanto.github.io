# 进程内存

在现今操作系统中，每个进程都有自己的内存空间——虚拟地址空间(virtual address space)。从应用程序的角度出发，它对物理内存一无所知，也不需要知道，我们在代码中操作的内存地址，都只是虚拟地址；而从系统的角度出发，它所管理的多个进程并不是同时在内存中拥有内存，而且各个进程拥有的内存还不一样，进程在多次运行间拥有的内存地址也不一样，这一切都是系统调度的结果。下面将以windows为例进行描述。

## 虚拟地址空间

一系列虚拟内存地址的集合称为虚拟地址空间。代码中操作的地址均为虚拟地址。系统为每一个进程保存了page table的东西，用于将每个进程的虚拟地址映射到某个物理地址上。一套虚拟地址空间可以理解为是程序运行时的整个内存空间。这片内存空间被划分为两部分——系统内核部分以及程序部分。程序代码仅能够访问程序部分内存，否则会引发错误。

当一个进程被执行时，不是所有虚拟地址中的内容都被加载到物理内存中。每个进程只有部分虚拟地址中的内容被加载到物理内存中，这部分内容称为working set，被加载的内容会构成一个或者多个page。当进程需要访问某些不在物理内存中的内容时，操作系统会将其从硬盘等外部存储器中读取入物理内存中；而当某些page很少访问而此时又有其它进程内容需要加载时，这些page就会被放回到硬盘中。这些操作对于应用程序而言是完全透明的。

## 进程的内存布局

虚拟地址的布局如下：

![program in memory](img\program_in_memory.png)
(图片出自[此处](https://gabrieletolomei.wordpress.com))

*图中内存大小分布以及地址排布仅作参考，不同操作系统以及不同的设置都可产生不同的结果。*这里我们只关注虚拟地址空间的分布情况。

如前所述有部分地址空间是操作系统内核保留，这部分应用程序无权干涉。

### 栈 stack

栈存放的是栈帧的数据(stack frame)。一个栈帧由如下几部分构成：

* 函数返回后执行的下条命令的地址
* 函数的所有参数
* 函数中产生的局部变量
* 可能被函数修改的寄存器的原始值。

栈帧会在函数返回后以更改栈顶指针的方式“释放”内存空间，等有下一个栈帧压入时，覆盖原来的数据从而重复利用栈空间。栈空间一般不大，可以通过设置编译选项进行修改。栈是从高地址往低地址生长。

栈分配空间迅速，分配内容直到对应函数返回前均存在。

### 堆 heap

堆是一块相对自由的内存区域，用于在进程运行过程中动态分配内存。c/c++可调用malloc/free操作堆内存，从而完成分配与释放。堆上数据分配后直到free前均存在，仅可通过free将其释放后方可被系统重新分配。

堆分配空间相对缓慢，特别是利用malloc以及free，需要进程从用户态切换到系统内核态执行内存操作；由于堆空间相对栈更大更灵活，故可用于存储内存消耗较大的数据；堆是从低地址往高地址生长。

### BSS段

未初始化的全局或静态变量，该区域中的初始值不确定，某些情况下可能会被初始化为0，编码时应尽量为其安排初始值。BSS段的内存数据可供读写。

### Data段

data段存放的是初始化的全局变量，该段又被分为两个部分，一个是可读写部分，另一个是只读部分。

```c++
int a = 10;
const char* str = "hello world";
```

a能够在运行时被修改，所以其存放于读写部分；而str是指向常字符变量的指针，指针在运行时可被修改指向的对象；而`hello world`是字符常量，被存放在只读部分。

### Text段

Text段中存放的是只读的程序指令。通常同个应用的多个进程会共用同一块Text段。