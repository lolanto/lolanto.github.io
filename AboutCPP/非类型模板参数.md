# 非类型模板参数 -- Non-type template parameter

模板参数既可以是类型，也可以是一些常量，非类型模板参数就是指后者。

非类型模板参数有以下几种写法

```c++
template<int N>... // 常量
template<const int* ptr>... // 指针
template<void (*func)(char*)>... // 函数指针
template<char (&arr)[8]>... // 引用
```

首先，模板是给编译器看的，所以无论是何种模板参数，都需要在编译时能够获得具体的值或者地址。对于非类型模板参数更是如此。

比如说第一个的常量参数N，该参数要么是`const int a = 10`，要么干脆就是字面量10，因为它们在编译时就已经分配了内存空间存储对应的值，可以获得存储实际值的地址。

对于指针常量而言就需要注意，传进去的虽然是指针，但存储这个“指针”的内存却应该是属于常量本身的。举个例子来理解：

```c++
int arr[] = {1, 2, 3};
const int* ptr = arr;
```

arr是数组，虽然我们可以将arr理解为`int* const`类型的指针，但事实上，数组和指针有本质的不同。数组代表的是一块连续的内存区域，大小由数组大小决定；而指针是一个4字节大小的内存区域，当中的值为所指变量的内存地址。所以，我们直接访问arr，它的值是数组的内存地址，而&ptr获得的是存储指针的内存地址。

回到用指针作为非类型模板参数上，假如我们用arr作为参数可以顺利编译，但假如使用ptr却会报错——"because of ptr is a variable, not the address of a variable!"

同样的道理

```c++
const char* ptr1 = "hello"; // false
char ptr2[] = "hello"; // true

struct ss {..};
const* ss ptr = ... // false
const ss obj = ... // true. use &obj as parameter!
```

函数指针作为非类型模板参数尚且未有研究，暂不讨论。

对于引用类型的非类型模板参数，这里仅讨论对数组的引用。引用的类型必须是完整的类型，也就是数组的长度将不可省略。毕竟`char[10]和char[11]`是两种类型。暂时还没有绕开这个设定的方法。

最后需要提醒，作为非类型模板参数的实参，不能是局部变量(例如函数中的临时变量)或者动态绑定的变量，因为它们无法在编译时候获得稳定的地址。最好使用全局常量作为实参。