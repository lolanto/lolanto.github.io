# 关于c++内存管理--构建并管理自己的内存池

文章主要讨论c++相关的内存池实现技术与思想。

---

以下是对[Building your own memory manager for C/C++ projects](https://www.ibm.com/developerworks/aix/tutorials/au-memorymanager/index.html)的部分翻译

## 为什么要创建自定义的内存管理器

在感谢内存管理器为提高程序效率所作出的贡献之前，我们先来回顾一下c/c++默认的内存管理。标准库中涉及内存管理的函数包括C的`malloc`,`free`,`calloc`以及`realloc`C++引入的`new`,`new[]`,`delete`,以及`delete []`。

类似`malloc`和`new`是通用的内存分配函数。你的代码可能只支持单线程操作，但`malloc`默认能够支持多线程操作。这种额外提供的功能使得这个函数在你的程序中显得效率不高。

`malloc`和`new`在分配内存时会调用操作系统的核心函数，而在释放内存时也会调用操作系统的核心函数。这就意味着，程序每次进行内存操作时，都要从用户态切换到内核态。所以那些频繁调用`new`或者`malloc`等内存操作函数的程序最终都会运行得很慢。

那些在程序中被申请出来的内存区域往往会被忘记释放，而c/c++又没有提供自动的垃圾回收功能。这就使得程序的内存占用不断增加。在大型程序中，该问题会给程序性能带来致命打击，因为能够使用的内存越来越少，同时系统启用的虚拟内存带来了许多磁盘操作，进一步降低效率。

## 内存管理器的设计目标

内存管理器应该满足以下几个设计目标：

* 速度
* 稳定性
* 易用性
* 可移植性

### 速度

内存管理器必须比编译器提供的内存管理器速度快。重复的内存分配和释放不应该影响程序运行效率。假如可以的话，内存管理器应该对程序中典型且大量进行的内存分配行为进行优化。

### 稳定性

内存管理器必须在程序结束前将申请的内存归还给系统。也就是说内存管理器不应该出现内存泄漏的情况。另外，内存管理器应该能够处理错误情况(比如无法分配过大内存空间)并提供相对稳定的错误恢复方法。

### 便利性

内存管理器的嵌入对原有代码的影响应该尽可能少。

### 可移植性

内存管理器应该能够轻松地在各个操作系统间移植，其内部实现不应该使用于平台有关的特性。

## 创建内存管理器的几个有效策略

以下几个策略对创建内存管理器有一定作用

* 请求足够大的内存区域
* 对一般性请求进行优化
* 收集被删除的内存空间

### 请求足够大的内存区域

这是最广为人知的内存管理器策略——在程序启动时申请一片较大的内存区域，尔后再断断续续地补充申请额外的内存区域。各个对象需要申请内存时，均从内存管理器管理的内存区域中分配内存空间。这个方法可以减少对操作系统核函数的调用，提高程序运行效率。

### 优化一般性请求

程序中可能会频繁申请某一固定大小的内存区域，不同的程序大小可能会有所不同。假如内存管理器能够对这种情况进行特殊优化，程序效率会有显著提高。

### 收集被删除的内存空间

被删除的内存空间应该被收集起来。当有其它内存申请时可以优先从这些“废弃”的内区域中分配，使得弃用的内存空间能够被重用。这个方法能够减少程序对内存的使用。

---

