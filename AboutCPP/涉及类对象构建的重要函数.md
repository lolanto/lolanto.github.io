# 涉及类对象构建的重要函数

本文介绍构造类对象过程的几个重要函数：构造函数，拷贝构造函数，赋值操作符，析构函数，移动构造函数以及移动赋值操作。分别介绍这几个函数的作用，调用时机。

## 构造函数

负责类对象构建的重要函数，若类定义中没有任何构造函数，则编译器提供默认的无参构造函数。默认的构造函数不保证类中定义的数据成员的初始化。若类定义中有任何的构造函数，则编译器不提供无参构造函数。

构造函数可以像普通函数一样被重载。

当类为派生类时，构造函数需要以初始化列表的形式调用基类的构造函数。先执行基类构造函数，后执行子类构造函数。

当类需要虚继承时，初始化与普通继承一样。

**调用时机**：为了与之后的几种构造函数区别，当类对象被“凭空”创建时，构造函数被调用。意思是只依赖构造函数的参数构建类对象，构造过程中没有已经创建的类对象参与(当然，假如参数中硬是加入类对象的话，又另当别论了)。

## 拷贝构造函数

先介绍**调用时机**：总的而言是使用一个已经存在的对象**初始化**另外一个对象！

1. 另外一个对象可能是函数体中声明的一个对象
2. 将一个对象以值传递的方式传入到函数中，函数参数就是另外一个对象
3. 以值传递的方式将函数中的值返回时，“返回值”的构造会调用拷贝构造函数

以下是拷贝构造函数的两种写法

```c++
class T {
public:
    T(T&);
    T(const T&);
}
```

一般而言仅会编写**常引用**为参数的拷贝构造函数，因为拷贝构造的重点是创建一个新对象，现有对象不应该被修改。同时，常引用作为参数是一个万能参数，不管输入参数是否为常量均能接受。

以下假设两种拷贝构造函数均存在。

```c++
T a;
const T b = a;
T c = b;
```

由于a非常量，所以构造b时会调用非常量的拷贝构造函数；而b是常量，所以构造c时会调用常量版的拷贝构造函数。

```c++
T func(T a) { return a; }
//...
T c = func(b);
```

传参时，相当于使用b构造a，此时调用哪个版本的拷贝构造函数就依赖于b的修饰符。

而返回时，由于代码执行已经超出了函数范围，所以a应该被销毁，但由需要依赖返回值构造c，此时需要将a拷贝到栈外的寄存器中，用这个寄存器中的临时变量初始化c。

所以返回时，又会调用一次拷贝构造函数，而调用的函数版本就有点迷(根据实践，当b是常量类型是，返回值的构造会调用非常量版本的构造函数；而b是非常量时，调用的却是常量版的构造函数)，不知如何解释。

虽然按道理来说，上述过程应该发生，但在实际过程中，该过程造成了巨大开销。上例中函数func的执行仅仅是为了初始化c，但中间却经过了两次构造和析构，十分浪费资源。所以编译器都会默认进行返回值优化，即**RVO**或者**NRVO**。除非编译时提供参数*-fno-elide-constructors*，否则无法看到上述的浪费过程。

通过上例同时想说明，**应该仅实现常量版本的拷贝构造函数**，因为编写过程中可能会调用到非常量版本的拷贝构造函数，而非常量版的拷贝构造函数中可能无意间修改了对象数据，引入错误。

## 赋值操作

赋值操作不属于构造对象，应该算是修改对象，但为了区别于拷贝构造函数，此处仍然对其一提。

当且仅当诸如`a = b`此类语句执行时，才会调用赋值操作(a,b均已初始化)。

```c++
const T& operator=(const T& v);
const T& operator=(T& v) const;
```

还有很多合法的写法，只需要注意这里面几个const修饰符的意思就可以了。

返回值的const修饰符说明了返回的是一个常引用，通常都是当前对象的引用；也可以返回普通引用。由于函数签名不包括返回值类型，所以返回值是否为常量不足以完成函数重载。

参数中的const说明传入的是常引用，不可修改参数。这也符合赋值操作的语义，使用传入的参数修改被赋值的对象。不是常量也可以。

最后的const是修饰这个函数的调用者，也就是被修改者是一个常量(也可以不是，只是在函数中会被当成常量处理)。其实这样有点违反赋值操作的语义，既然被复制就应该需要被修改。

## 移动构造函数

这是c++11中的新特性，移动的意思可以理解为“把A拿到B”。上面的例子中提及到函数返回值用于初始化某个变量，而后返回值将会被销毁。此处就可以使用“移动”的方式，将原本属于返回值的内存区域交给要初始化的变量管理，如此一来，返回值申请的变量得以继续使用，又省去了为新变量申请内存空间的过程。

移动构造函数的写法如下：

```c++
class T {
    T() {/* do some thing*/}
    T(T&& v) {/*moving!*/}
}
```

注意两个&，意味着v是一个右值，即即将被回收，不可再访问的值。构造函数中可以将v中申请的一些堆内存“放”到新的对象下，如此一来v申请的内存不用回收，新对象也不用申请。

```c++
T func() { return T(); }
T b = func();
```

上述过程中，func内创建一个匿名变量`T()`，而后使用该匿名变量作为返回值。创建返回值时，由于T()是一个函数，返回值为右值，所以会使用移动构造函数构造返回值；而后func返回值本身也是一个右值，故再次调用移动构造函数初始化b。

在编写移动构造函数时，参数尽量使用非常量右值引用，因为移动构造函数的语义往往要求对右值进行修改。

当类提供了移动构造函数时，编译器不会提供默认的拷贝构造函数。

## 移动赋值操作

和移动构造函数是一个道理，只是换成对赋值操作的重载。写法如下

```c++
const T& operator=(T&& v) {/*moving*/}
```

注意，这里的v依然是非常量的右值引用，还是因为在这里右值内容可能需要被修改，也能够被修改，用const修饰不符合语义。

## 析构函数

析构函数在对象被销毁时调用，对象销毁的时机主要有两个：

1. 超出作用域，对象在栈上而被回收掉
2. 堆上的对象被显式delete

析构函数最重要的作用是直接或间接释放其它被存放在堆中的内存。比如类中有指向堆的指针作为成员变量而且已经分配了对内存，则需要在析构函数中将其delete；或者成员变量包含了对某个资源的一个引用，应该在析构函数中减少该资源的一次引用计数。

析构函数写法简单`~T()`不返回，不接收任何参数，不应该被直接调用。

对于继承的子类，父类的析构函数应该为虚函数；当运用多态时，父类指针被delete时会先调用子类析构函数，而后再是调用父类析构函数。若父类析构函数非虚函数，则delete时会造成子类析构函数无法被调用而引入错误。

析构时，先析构子类后析构父类。