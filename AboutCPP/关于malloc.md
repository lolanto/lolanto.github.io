# 关于malloc

---

c++中的new默认实现是依赖malloc完成的。而malloc是C/C++标准库中规定的内存申请函数，函数的实现由库(操作系统)控制。

在linux上，malloc分为两层，分别是用户层与内核层。

## 用户层

在这个层面上，堆空间分成了*已分配内存块*与*空闲内存块*两个链表。当使用malloc时会从空闲内存块链表中查找适合大小的空闲内存块，将其挂到已分配内存块链表下，并进行返回，当free时，就把分配的内存块挂到空闲内存块链表下，等待下一个malloc使用。

## 内核层

然而当malloc没办法从空闲内存块链表下获得足够的内存空间时，就需要通过系统调用完成内存申请。操作系统通常对虚拟内存空间中，堆部分的限制地址进行修改，并完成虚拟地址空间到物理地址空间的映射关系，从而完成内存的申请并返回。

malloc和free一般不会频繁进行系统调用，而是以链表的方式进行缓存，对于free而言，只有当空闲内存块足够大时(比如40KB)才返回给操作系统。

这也是为什么内存管理器从一开始就申请足够大的内存空间进行内存管理，就是避免过多调用malloc/new/free/delete，从而避免不可控的系统调用。



所以，内存管理器的一个作用，就是通过预先向系统申请足够大的内存空间，并采用自己的内存控制算法管理内存分配，而不依赖系统的默认实现，将绝大部分内存控制的权力掌握在自己手中。