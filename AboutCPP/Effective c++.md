# About Effective C++

目前可理解的条款及其简单陈述

> 高效不在于真的提高了软件的性能,而是提高了程序开发过程的效率,避免误用c++而增加排错的难度.

## 1. 尽量以const, enum, inline替换#define

\# define为文本替换，不提供内存安全检查

## 2. 为多态基类声明virtual析构函数

使用基类指针指向子类对象时，使用delete释放指针。若基类析构函数没有声明为虚函数，则只会调用基类析构函数，使得子类对象的动态分配资源泄漏。

凡是直接或间接(继承)拥有虚函数的类对象，都必定会含有指向虚表的指针，注意类大小。

子类的析构函数会在运行结束后调用父类的析构函数

## 3. 不让异常逃离析构函数

析构函数中发生异常可能会使程序过早退出，出现未定义行为

若必须在析构函数中进行可能抛出异常的操作，将该操作用函数包裹并提供用户手动调用的权利，让用户能够处理异常；析构函数中将可能出现异常的行为包裹于try catch中，“吞下”异常或者记录日志并中止程序

## 4. 绝不在构造或析构过程中调用virtual函数

构造过程中从基类开始构造，基类构造函数调用虚函数并不会真的触发子类中重新定义的虚函数，因为此时子类并未构造完成；

析构过程子类会被先析构，与构造过程同理，基类调用的虚函数同样会有问题，因为子类已经不存在了；

本条款的意思是：构造/析构函数调用virtual函数并不能完成目标语义，避免使用防止代码理解出错。

## 5. 令operator=返回一个reference to *this

返回调用者自身的引用，使得自定义类的赋值行为与基本类型行为一致

## 6. 在operator=中处理“自我赋值”

函数执行结束应该仅有两个状态：数据获得目标状态(函数执行成功)；数据维持原有状态(函数执行失败)。

operator=中出现异常时，应该让被赋值者维持原有状态

## 7. 以对象管理资源

RAII，用对象于其析构函数中删除动态申请的资源，而该对象位于栈上，从而保证动态申请资源能够正常归还。

负责资源管理的对象必须注意拷贝行为，根据所管理资源是唯一的或是允许重复来设计拷贝/赋值函数行为。

## 8. 以独立语句将newd对象置于智能指针

```c++
func(shared_ptr<T>(new T), otherFunc())
```

由于无法假设编译器处理实参的顺序，若其处理顺序为：

* new T
* otherFunc()
* 将指针置于智能指针

则一旦otherFunc()抛出异常，new T便无法利用智能指针进行释放导致内存泄漏。

故应将`shared_ptr<T>(new T)`单独成句，保证资源一定受管理对象管理。

## 9. 确定对象被使用前已先被初始化

* 基础类型数据手动初始化，c++不保证初始化值(通常会在Release模式下引入错误)
* 类非静态成员变量初始化顺序为声明顺序；在构造函数的初始化列表中进行的才是初始化操作，在函数体中以=进行的是赋值操作，成员变量在赋值前已经通过默认构造函数进行初始化
* 不要假设静态变量的初始化顺序，即这些变量的初始化过程不应该互相依赖，最好利用“单例”形式，保证函数调用时对象必定初始化。

## 10. 让接口容易被正确使用，不易被误用

利用函数的返回值，参数类型强迫用户使用正确参数与接口交互。

## 11. 尽量传递引用类型参数，减少使用值传递

最基本的——值传递引发对象内部数据的拷贝行为，一旦数据量多，性能和存储空间损失较大；大部分编译器的引用实现方式为指针，拷贝带来的牺牲较小；

是否能够使用值传递的判定标准不在于对象的大小，因为拷贝的含义是“拷贝该对象相关的所有数据”，即包括指针指向的内容；

值传递不支持多态，当将子类对象作为参数传递给父类型参数时，对象被“割裂”，实参对象的虚函数调用都会是父类函数，而非子类。

## 12. 别妄想返回引用都会带来便利

从函数中返回引用十分危险，一旦引用对象为函数栈上对象，函数返回时栈将销毁，引用销毁对象引发不确定行为。

## 13. 将成员变量声明为Private

该操作提高类对象的封装性——仅提供功能性的public接口，使得功能的实现变更对代码影响程度降低。

## 14. 宁以非成员，非友元函数替换成员函数

越少代码能够访问对象数据，对象封装性越高。越高封装性意味着类本身的修改对程序影响越小。

当某个成员函数功能能够使用非成员，非友元函数替换时，应该考虑使用替换。因为引入一个新的成员函数意味着能够访问对象数据的代码更多(即使这些代码属于类本身)，封装性变低。

## 15. 尽可能延后定义式的出现时间

当函数由于异常等原因提前结束，某些已定义的变量将不能发挥任何作用，此时这些变量将造成浪费，故尽量让变量的定义直到真正需要使用它之前才完成。

## 16. 尽量少做转型动作

如`reinterpret_cast`，其对内存直接进行操作。该转型意味着对内存布局进行了假设，而数据的内存布局由编译器实现决定，故该代码无法满足平台兼容需求。

## 17. copy-and-swap

将需要修改的对象进行拷贝，并在拷贝对象上进行修改，当所有修改完成后再交换拷贝和原版，从而保证对象的修改出现错误时，对象保持未修改前的状态

带来额外的处理和存储开销

## 18. 减少编译依赖

### pimpl

存在两个类Aptr以及A，其中A类包含了对象的完整实现(包括数据以及方法)，Aptr仅包含A类的指针作为成员以及A类提供的接口。此时可以在编译单元中使用Aptr替代A，A中发生的任何改变不会导致编译单元的重新编译。具体文件安排如下：

```c++
// A.h
class A {...} // A的声明
// A.cpp
#include "A.h"
... // 提供A的定义
// Aptr.h
class A;
class Aptr{private: A* _pimpl;} // 提供A的前置声明，以及Aptr声明A的接口，并包含A的指针
// Aptr.cpp
#include "A.h"
#include "Aptr.h" // 完成A到Aptr的接口调用
```

##19. 确保public继承的语义为is-a

当且仅当“A是一种B”关系成立时，才对A公开继承B。

一旦使用public继承，意味着子类必须完成父类的所有行为，否则破坏is-a的语义。

## 20. 避免继承覆盖名称

继承的名称覆盖和重载不一样——只认名字。考虑如下代码

```c++
class Base {
    public:
    int m1(int);
}
class Derived : public Base {
    public:
    int m1();
}

Derived d;
d.m1(2); // 错误！
```

派生类仅声明了无参的`m1`，但由于其名称与父类相同，故也就覆盖了父类了有参`m1`。

使用using可以将外层的名称引入，接上例

```c++
class Derived : public Base {
    public:
    using Base::m1;
    int m1(int);
}
```

此时Base中的所有的m1都被引入子类中，而且会触发函数重载和覆盖，即父类中与子类签名相同的函数会被子类覆盖。

using将上层指定名称内容全部引入，若部分引入，则：

```c++
class Derived : public Base {
    public:
    int m1() { return Base::m1(); }
    int m1(int);
}
```

## 21. 接口继承与实现继承

* 纯虚函数——仅继承接口
* 虚函数——既继承接口又默认(强制)提供缺省实现
* 非虚函数——强制继承接口以及实现

函数形式只是实现设计语义的工具；考虑有语义为“要求继承接口，但除非继承者主动要求，否则不提供默认实现”。仅使用虚函数是无法完成该需求，可以结合纯虚函数以及非虚函数完成。

```c++
class Base {
    public:
    virtual void func() = 0;
    protected:
    void defFunc() { /*Do something!*/ }
};
class Derived : public Base {
    public:
    virtual void func() { defFunc(); } // 既可执行默认行为，也可重新定义
}
```

## 22. 虚函数的替代方案

### 1. Non-Virtual Interface方法实现**Template Method**模式

如下所示

```c++
class Base {
    public:
    int func() {
        //... some behavior
        behavior();
        // ... some behavior
    }
    private:
    virtual void behavior() { /*Default Behavior*/ }
};
```

继承者可以通过继承并修改`behavior`，完成func的不同行为，而基类能够控制behavior“何时被调用的权限”

### 2. 通过Function Pointer实现Strategy

相当于外部提供函数指针，使得同一个对象因为赋予不同指针而动态拥有不同行为。在灵活度上比虚函数高，但外部函数指针无法访问对象数据。

函数指针可以使用std::function进行包裹，从而兼容一切可被转换成函数的数据结构：普通函数，lambda(函数对象)以及成员函数

## 23. 绝不重定义继承的非虚函数

这是关乎继承语义的问题，非虚函数希望继承者能够拥有与被继承者相同行为，重定义后即违反该语义。

## 24. 绝不重定义继承而来的缺省参数值

“虚函数是动态绑定的，而函数的缺省值是静态绑定的”，如：

```c++
class Base {
    public:
    virtual void func(int = 1);
};
class Derived : public Base{
    public:
    virtual void func(int = 2);
}
// ...
Derived de;
Base* ptr = &de; ptr->func(); // 缺省参数为1
Base& ref = de; ref.func(); // 缺省参数为1
```

重定义缺省参数没有意义，因为编译器实现“运行期决定虚函数缺省参数值”很困难，所以干脆不做了。

## 25. 实现has-a或is-implemented-in-terms-of关系

(组合) 在类中包含其它类型对象，从而构成has-a关系；而利用其它类型对象提供的功能，加以修饰(限制)后完成本类型提供的功能，从而构成is-implemented-in-terms-of

private继承同样可以实现is-implemented-in-terms-of关系。private继承可以利用被继承者的接口实现自身的某些功能，但该继承从语义上而言并不存在is-a的关系。

private继承可以使用组合方式替代

```c++
class SomeObject {
	private:
    class OtherObject : public AnotherObject {
        public:
        // some function is implemented with Interface produced by AnotherObject
    }
    OtherObject oo; // using this to use interface produced by AnotherObject
}
```



当面对"并不存在is-a关系的两个classes，其中一个需要访问另一个的protected成员，或需要重新定义其一或多个virtual函数，可以考虑使用Private继承"。

## 26. 处理模板化基类内的名称

有以下模板

```c++
template<typename T>
class Derived : public Base<T> {
    public:
    void func() { baseFunction(); }
}
```

func中希望调用基类定义的函数，但编译器拒绝该操作。因为编译器不知道Base\<T\>(特别是特化版本)是否支持`baseFunction`，所以编译器拒绝进一步搜索父类函数。

可以使用诸如`this->baseFunction()`，`using Base<T>::baseFunction`以及直接`Base<T>::baseFunction()`，向编译器承诺无论Base\<T\>是特化版或者泛化版，一定有`baseFunction。`

## 27. 慎防模板膨胀

每通过模板生成一个类或者函数，都会增加程序的二进制体积，所以应该考虑将模板中可被重用的部分抽离成诸如函数的形式进行调用。