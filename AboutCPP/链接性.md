# c++链接性

链接性分为**内部**链接性，**外部**链接性以及**无**链接性。外部链接性允许目标在不同文件中被访问，并拥有共同的内存空间；内部以及无链接性只允许目标在自身文件中被访问。

## 对变量而言

### 自动变量

由编译器负责创建以及销毁的自动变量(如函数块中的参数以及变量，一般存储在栈上)为无链接性变量。

### 静态持续变量

```c++
int AnInt = 10; // 外部链接性
static int AnotherInt = 20; // 内部链接性
void AnyFunc() {
    static int AnonymousInt = 30; // 无链接性
}
```

`AnInt`拥有外部链接性，意味着其它文件能够读写该变量，在其它文件中需要使用`extern`关键字修饰`AnInt`表明该变量在其它文件中已定义。

```c++
// another file
extern int AnInt;
// int AnInt; 由于具有外部链接性，与上一个文件的AnInt构成重定义
```

这也解释了若在头文件中声明某变量后，该头文件又被多个代码文件包含就会出现重定义问题。

`AnotherInt`具有内部链接性，只能在其声明的文件中被访问；其它文件可以声明具有外部链接性或者内部链接性的同名变量，其他文件声明的变量不会影响当前`AnotherInt`所在文件的变量，因为其*覆盖(hide)*了来自其它文件外部链接性的同名变量。

```c++
// another file
int AnotherInt; // Ok
// another file
static int AnotherInt; // Ok
```

在函数中声明的`AnonymouseInt`没有链接性，只能在其所在函数中被访问及修改。

### const

`extern`修饰符表明某个变量为外部链接性变量且已在其它文件中被定义。而`const`修饰的变量则拥有**内部**链接性，意味着其它文件不能访问该常量。

```c++
const int AnInt; // internal linkage
extern const int AnotherInt; // use extern to modify its linkage to external linkage
```

在头文件中使用`const`修饰某个常量后，所有包含该头文件的代码文件都会有各自独立的同名常量。使用`extern`覆盖`const`的链接性后，不能在头文件中将其定义，否则同样会出现重定义问题，只能在其中一个代码文件中进行定义。

## 对函数而言

函数链接性默认为**外部**链接性(使用`extern`关键字修饰，可选)，意味着一个函数的定义只能在一个文件中出现；也可以使用`static`关键字修饰。

关键字一般用于修饰函数原型(声明)，当编译器发现函数原型中使用`static`修饰时，则只从当前文件范围中搜索函数定义；若函数原型显示函数为外部链接性，则从其它文件中寻找函数定义，若找到多个函数定义则报重定义错误，这也解释了为何不将函数定义放在头文件中；假如在代码文件中没有找到函数定义，则从链接的库中寻找——*意味着用户定义的函数能够覆盖库函数*。

关键字也能用在函数定义上，一般是当前这个代码文件中利用函数定义充当函数原型时使用，道理和函数原型一样。

### inline内联函数

内联函数是将函数代码扩展到调用位置上，类似于宏，不考虑链接性。使用内联函数时，函数原型或者函数定义必须用inline进行修饰，且调用内联函数的代码文件中必须包含内联函数的定义；所以内联函数一般在头文件中提供函数定义。

### 语言连结性--extern "C"

编译时函数会有不同的符号名，比如`fun(int)`在C编译时为\_fun。而由于c++有函数重载，所以函数符号名需要结合函数参数进行命名如`func(int)`为\_func\_i，`func(double, int)`为\_func\_d\_i。

当使用C编译生成的库时，需要使用关键字`extern "C"`声明调用的库的原型，此时C++编译器将该函数符号名用C的方式进行计算，再从C库中寻找。同理也有`extern "C++"`。