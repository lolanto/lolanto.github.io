# 程序员的自我修养(一)

## 1. 基础内容

### 基本硬件架构

南桥：负责管理慢速总线，该总线上连接着外部设备，包括打印机，鼠标，键盘等；同时负责与北桥合作

北桥：管理告诉总线，该总线上连接着CPU，主存

### 多核与多处理器

多处理器比如对称多处理器(SMP, Symmetrical Multi-Processing)，是实实在在地在主板上安装多块CPU芯片，每个CPU有自己的多级缓存；而多核处理器仅是将多个运算和控制芯片封装在一起，这些芯片共享多级缓存

### 多任务系统

操作系统本身也是一个程序，只是这个程序运行的权限级别很高；其它程序则以进程的方式运行在比操作系统权限低的环境下。每个进程都有自己独立的地址空间(虚拟地址)，进程之间互相隔离。当某个进程运行了一定时间后，操作系统暂停该进程，并将CPU资源分配给另外一个等待的进程；当进程间切换足够快时，就相当于“多个进程同时执行”。

### 驱动程序

提供某一硬件功能，负责处理运行该功能涉及到的硬件细节(数据应该写往哪个地址)，驱动程序根据操作系统提供的接口以及硬件厂商的标准编写，一般由硬件厂商提供。

### 虚拟地址与物理地址

虚拟地址是人为假设的，每个应用程序所在的内存空间。CPU获得的虚拟地址，需要利用MMU完成虚拟地址到物理地址的转变，从而完成获取主存(硬盘)数据的任务。

程序运行时会将程序的虚拟空间映射到物理内存空间，并采用**分页**的方式，仅将当前需要运行的部分映射到物理内存中，而尚未被使用的部分映射到硬盘中。

### 线程

程序执行的最小单元。线程拥有线程ID，指令指针，寄存器以及栈。一个进程由一个以上线程构成，每个线程共享进程的代码段，数据段以及堆，还有一些进程及资源(文件和信号)。

线程有三个状态:

* 运行(Running): 表示线程正在使用CPU，当线程时间片耗尽后进入就绪状态；或者需要外部设备响应时，进入等待状态
* 就绪(Ready): 当前线程可执行，但尚未分配到CPU资源，当被分配资源后，进入运行状态
* 等待(waitting): 当前线程在等待某一事件发生，暂时无法执行，当事件发生后进入就绪状态

当CPU中断某个线程时称为**抢占**，当线程主动让出CPU时成为**不可抢占**，目前绝大部分都是抢占的

### 线程安全

关于锁：

二元信号量(binary semaphore): 只有两种状态(0/1)，第一个试图获得该信号量的线程将其设置为占用状态，其他线程需要获取时，必须等待锁的释放

多元信号量: 简称信号量，该锁可同时被N个线程占用。当某个线程试图获取锁时，N不为0，则该线程获得锁并使N减一；若N为0，则等待其它线程锁的释放。当释放锁时，N加一。

互斥量(mutex): 和二元信号量一样的规则，但信号量能够被**其它线程释放**，而互斥量只能在申请的线程内被释放。

临界区(Critical Section): 规则与互斥量相同，但互斥量和信号量在其它进程中可见，而临界区不行。

读写锁(Read-Write Lock): 多线程可同时读某个数据，但不能同时写，或者既有读又有写的行为。故当锁处于自由状态时，线程可以获得该锁并根据自身需要设置锁状态为读/写；若当前锁处于读状态，而线程需要写，则必须等待锁恢复自由；当锁处于写状态，任何线程都不能获取该锁，直到其释放。

条件变量(Condition Variable): 使多个线程等待某信号发出后再恢复执行。

### 过度优化

编译器处理多线程时可能会出问题：

1. 将变量缓存到寄存器，而线程间寄存器值是独立的，导致出错
2. 编译器器将两条上下无关的语句执行顺序进行更换
3. CPU乱序执行导致错误

---

## 2. 编译与链接

从源码到执行程序，总共经过了如下几个步骤：

### 1. 预编译(preprocess)

将源码中的宏定义展开，将包含的头文件递归展开，删除所有的注释，添加行号以及文件名标识符，保留编译器命令(#pragma)

### 2. 编译

编译过程进行词法分析，语法分析，语义分析以及优化，最终生成汇编代码；

词法分析扫描处理后的代码，生成一系列的记号(token)

语法分析使用这些记号生成语法树

语义分析在语法树的基础上对声明和类型进行匹配，完成类型的转换等

由于汇编指令与硬件有关联，为了能够让编译器有一定的移植能力，在生成汇编之前会先生成中间语言(比如三地址码)，我们称生成中间语言的这部分工作由**编译器前端**完成，而生成汇编代码的工作由**编译器后端**完成。

### 3. 汇编

该过程将汇编代码与机器指令进行一对一转换

> 以上步骤在编译器中完成

### 4. 链接(静态链接)

将当前编译单元中未定义的符号进行处理，用其它编译单元中对该符号的定义取代之。该步骤使用**链接器**完成。

之所以需要链接是因为源码规模不断扩大，无法使用单一文件完成编码，当拆分成多个文件后，不同文件之间相互引用的内容在编译过程不可见，所以在生成最终目标文件之前，必须将未完成的引用填补完整，故需要链接。

链接器负责**地址和空间分配**(虚拟空间)，**符号决议**以及**重定位**。

在具体介绍链接过程前，先简单介绍链接过程的输入——目标文件的结构(windows下为obj)

### 目标文件结构

目标文件以**文件头**+**段**的方式将数据分开保存。

**文件头**包含了描述该目标文件的许多重要信息，关乎文件结构的几个属性包括——目标文件大小，段的数量，**段表**的位置以及字符串表的位置。

这里提及的**段表**是一堆数据，可解析为以 段属性描述结构体 为元素的数组，数组的大小即是目标文件中的段的数量。通过分析段表可以知道目标文件中每个段的位置，大小等属性。

我们比较关心的段包括：

* .text，可以称为代码段，在其它编译器下可能有不同的段名称，但功能相同——记录目标文件中的机器指令。在未进行链接前，涉及未定义引用的指令会用一些特殊值进行替代。
* .data，数据段，该段中包含了**已经初始化**的全局变量以及局部静态变量；还可能有一个段叫 .rodata，只读数据段，该段中通常保存只读的常量(const修饰)以及字符串常量
* .bss，也属于数据段，但该段中包括的是**未初始化**的静态全局变量以及局部静态变量。由于没有初始值，该段通常只会在段表中记录，而不会真正在目标文件中占据存储空间。记录在该段的数据可以通过符号表查询
* .relXXX，重定位表，X代表该表中包含的是哪个段需要重定位的内容，比如.rel.text代表该表是代码段的重定位表。
* .symtab，符号表，该表中记录了当前编译单元用到的所有符号，其中包括了变量和函数。符号表中与链接有关系的有两类符号：全局符号——在当前编译单元定义的，可被其它编译单元链接的符号，外部符号——当前编译单元引用的，没有找到定义的符号

### 开始链接

**空间与地址分配**

链接器扫描所有目标文件的段，和符号表。将符号表中的符号定义以及符号引用进行收集，构成一张**全局符号表**；同时将各个相同的段进行合并，计算长度与位置。

合并完段后，会为每个段分配虚拟地址；段中的符号同样也拥有了虚拟地址。

对于.bss段，其在合并后的目标文件中依然不占用存储空间，只是在段描述中声明该段占用的虚拟地址空间大小。

**重定位**

每个需要重定位的目标文件都有**重定位表**，即.relXXX，通过查询重定位表可以找到需要重定位的符号；在全局符号表中搜索需要重定位的符号，即可修正需要重定位的数据。若需要重定位的符号在全局符号表中没有找到，则会出现链接错误。

**符号决议**

符号决议发生在多个符号其定义类型不一致的时候，无法确定应该为该符号分配多少空间。对于未定义的全局变量未**弱符号**，对于已经定义的全局变量以及函数未**强符号**。

* 若两个以上强符号类型不一致，则报错(比如重定义的函数)
* 若一个为强符号，剩余为弱符号，则所有符号按照强符号处理
* 若所有都为弱符号，则按照声明占用空间最大的符号来处理

---

以上即为《程序员的自我修养》读书笔记的第一部分，交代了书中提及的计算机组成基础知识，介绍了编译器和链接器并着重说明了链接过程以及目标文件。